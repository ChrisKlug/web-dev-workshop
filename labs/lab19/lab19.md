# Lab 19: Consuming gRPC Services

The orders service is currently implemented as a separate service, which isn't available to the front-end. To fix that, you need to create a new endpoint in the web project for the front-end to use.

Because of the familiarity that a lot of people have with MVC; the choice has once again fallen on that technology for this endpoint. 

## Steps (for Visual Studio)

###  Creating a gRPC client

Before you can start implementing the required endpoint, you need a gRPC client to be able to talk to the oerders service. Creating is is fairly simple though.

Start by opening the __WebDevWorkshop.Web__ and adding the NuGet package __Grpc.AspNetCore__. This will be used to create the client, just like it was in the test project.

Once that NuGet package is installed, you need to get hold of the __orders.proto__file. Just as in the test project. And you need to do it in the same way. By adding a link to the file.

Add a new directory called __Protos__ and then add the __orders.proto__ file from the __WebDevWorkshop.Services.Orders__ project as a linked file.

__Note:__ Using a linked file is much better than adding a copy, because they will not go out of sync at any point with a link.

Next, open the __WebDevWorkshop.Web.csproj__ file, and make sure that the file has been added as a __&lt;Protobuf /&gt;__ entry. Like this

```xml
<ItemGroup>
    <Protobuf Include="..\WebDevWorkshop.Services.Orders\Protos\orders.proto">
        <Link>Protos\orders.proto</Link>
    </Protobuf>
</ItemGroup>
```

Once the proto-file has been "added" to the project, you need to configure it to only create a client. A task that can be done in 2 ways. 

The simplest way is to right-click on the __Connected Services__ node in the Solution Explorer, and choose __Manage Connected Services__. In the modal that opens, you can then click the three dots to the right, in the "orders - Client and Server" box and then __Edit__. In this modal, you can configure the type to be generated by simply selecting __Client__ in the drop-down. Then close the windows.

The seconds way, is to manually update the __&lt;Protobuf /&gt;__ entry in the csproj-file to include a property called __GrpcServices__ set to __Client__.

In the end, both options end up with an entry in the csproj-file that looks like this

```xml
<ItemGroup>
    <Protobuf Include="..\WebDevWorkshop.Services.Orders\Protos\orders.proto" GrpcServices="Client">
        <Link>Protos\orders.proto</Link>
    </Protobuf>
</ItemGroup>
```
Once you have the prot-file included, the source generator will do its thing, and you will get a client generated for you. So, all you need to do now, is to add that client to the IoC container.

Open the __Program.cs__ file, and add the auto-generated client to the `IServiceCollection` right before the creation of the `WebApplication`.

```csharp
builder.Services.AddGrpcClient<OrdersService.OrdersServiceClient>();
```

Now, that client needs an address to know where to find the service.

### Configuring the gRPC service address

Currently, there is no reference from the __webdevworkshop-web__ resource and the __webdevworkshop-services-orders__ resource in the Aspire configuration. And because of that, there is no way for the __webdevworkshop-web__ to get hold of the address to the __webdevworkshop-services-orders__ project. This needs to be sorted out...

Open the __AppHost.cs__ file in the __WebDevWorkshop.AppHost__ project and locate the __webdevworkshop-services-orders__ resource. As you can see, it is defined after the __webdevworkshop-web__ resource, maiking it impossible to add the reference. So, go ahead and move the __webdevworkshop-services-orders__ resource declaration before the __webdevworkshop-web__ one.

There is also no variable that holds a reference to the __webdevworkshop-services-orders__ resource. So, add that as well.

Finally, add a reference from the __webdevworkshop-web__ to the __webdevworkshop-services-orders__ resource

```csharp
var orders = builder.AddProject<Projects.WebDevWorkshop_Services_Orders>("webdevworkshop-services-orders")
    ...

builder.AddProject<Projects.WebDevWorkshop_Web>("webdevworkshop-web", "aspire")
    ...
    .WithReference(orders)
    .WaitFor(orders);
```

Now you have access to the required address in the __webdevworkshop-web__ project, making it possible to configure the gRPC client you just added.

However, the orders service resource has a very long name, which is a bit annoying when you want to point at it from the gRPC client. To fix that, rename the resource from __webdevworkshop-services-orders__ to __orders__

```csharp
var orders = builder.AddProject<Projects.WebDevWorkshop_Services_Orders>("orders")
```

You also need to run gRPC over HTTPS, and by default, the `http` launch profile is used. And thayt doesn't support HTTPS. 

To fix that, update the `AddProject()` call to pass in `"https"` as a second parameter to make Aspire use the __https__ launch profile that supports HTTPS

```csharp
builder.AddProject<Projects.WebDevWorkshop_Services_Orders>("orders", "https")
```

Nice! Now you can finally update the gRPC client registration...

Open the __Program.cs__ file again, and add a callback to the gRPC client registration, setting the `Address` property to a new `Uri` pointing to __https://orders"__

```csharp
builder.Services.AddGrpcClient<OrdersService.OrdersServiceClient>(options =>
{
    options.Address = new Uri("https://orders");
});
```

### Creating the endpoint

The last piece of the puzzle is to create the actual endpoint. And, as mentiond before, the choice has once again fallen on MVC, which means that you need a new controller.

Add a new, empty API controller called __OrdersController__ in the __Controllers__ directory.

In this case, orders should only be able to be added if a users is authenticated. So, add an `AuthorizeAttribute` to the controller to make sure it can't be called by unauthenticated users.

```csharp
[Route("api/[controller]")]
[ApiController]
[Authorize]
public class OrdersController : ControllerBase
{
}
```

You will also need a "model" to pass in the required information. So, add a new class called __AddOrderModel__ in the __Models__ directory.

The code for the `AddModelOrder` class should look like this

```csharp
public class AddOrderModel
{
    public required Item[] Items { get; set; }
    public required Address DeliveryAddress { get; set; }
    public required Address BillingAddress { get; set; }

    public class Item
    {
        public int ItemId { get; set; }
        public int Quantity { get; set; }
    }
    
    public class Address
    {
        public required string Name { get; set; }
        public required string Street1 { get; set; }
        public string? Street2 { get; set; }
        public required string PostalCode { get; set; }
        public required string City { get; set; }
        public required string Country { get; set; }
    }
}
```

With the controller and model in place, it is time to add the required MVC action. It should be called __AddOrder__, have an `AddOrderModel` parameter, and asynchronously return a `Task<IActionResult>`. And it should respond to POST requests

```csharp
[HttpPost]
public Task<IActionResult> AddOrder(AddOrderModel order)
{
}
```

Start the implementation by creating an `AddOrderRequest`, setting the `DeliveryAddress` and `BillingAddress` properties using the data in the `AddOrderModel`.

```csharp
[HttpPost]
public Task<IActionResult> AddOrder(AddOrderModel order)
{
    var request = new AddOrderRequest
    {
        DeliveryAddress = new Address
        {
            Name = order.DeliveryAddress.Name,
            Street1 = order.DeliveryAddress.Street1,
            Street2 = order.DeliveryAddress.Street2 ?? "",
            PostalCode = order.DeliveryAddress.PostalCode,
            City = order.DeliveryAddress.City,
            Country = order.DeliveryAddress.Country,
        },
        BillingAddress = new Address
        {
            Name = order.BillingAddress.Name,
            Street1 = order.BillingAddress.Street1,
            Street2 = order.BillingAddress.Street2 ?? "",
            PostalCode = order.BillingAddress.PostalCode,
            City = order.BillingAddress.City,
            Country = order.BillingAddress.Country,
        }
    };
}
```

__Note:__ Yes, it is missing a bunch of validation that would be there in a production system. However, since you are the only one that will use it, you will just have to trust yourself...

The next step is to add the ordered items. However, for this, you will need to get hold of the actual `Product` instances to get the product names and prices. And to do that, you need the `IProductsClient`. So, add a primary constructor that accepts a `IProductsClient` as a parameter

```csharp
public class OrdersController(IProductsClient productsClient) : ControllerBase
```

Once you have that, you can start retrieving the products. This is an asynchronous operation though, so you might as well do all the calls in parallel. Something that can be done by using the following code

```csharp
var retrievalTasks = order.Items.Select(x =>
                productsClient.GetProduct(x.ItemId)
              ).ToArray();
```

After you have started all the calls, you will need to wait for them to finish. And handle if something goes wrong. In this case, handling the error in a graceful way isn't really a priority, so you can simply return an HTTP 500.

```csharp
var retrievalTasks = order.Items.Select(...).ToArray();

try
{
    await Task.WhenAll(retrievalTasks);
}
catch (Exception ex)
{
    return StatusCode(500, "Something went wrong...");
}
```

__Note:__ Don't forget to make the method `async` now that you use `await`.

Once all the tasks have completed, you need to get hold of the actual results. Once again, a quick LINQ query is all you need

```csharp
catch (Exception ex) 
{
    ...
}

var retrievedProducts = retrievalTasks
                            .Select(x => x.Result!)
                            .ToDictionary(x => x.Id, x => x);
```

And then, it is just a maatter of iterating through the ordered items, and an `OrderItem` for each one

```csharp
foreach (var item in order.Items)
{
    var product = retrievedProducts[item.ItemId];
    request.Items.Add(new OrderItem
    {
        Name = product.Name,
        Price = (float)product.Price,
        Quantity = item.Quantity
    });
}
```

Once you have a fully formed `AddOrderRequest`, you need to send it to the service. However, to do that, you need a `OrdersService.OrdersServiceClient`. Luckily, as that has been added to DI; you can simply add another parameter to the constructor.

```csharp
public class OrdersController(
    IProductsClient productsClient,
    OrdersService.OrdersServiceClient ordersService
) : ControllerBase
...
```

That's it! Now you just need to call the service. And since it is a network call, it is a good idea to use a `try/catch` around it. Even if you in this case can simply return an HTTP 500...

```csharp
AddOrderResponse response;
try
{
    response = await ordersService.AddOrderAsync(request);
}
catch (Exception ex)
{
    return StatusCode(500, "Something went wrong...");
}
```

Once you have gotten the `AddOrderResponse` you need to make sure that it succeded. Remember, the `try/catch` will handle errors in the communication, but the actual service also has built in error handling that returns the error in trhe response. So, you need to make sure that the `Success` property is true. If it isn't, you should return an HTTP 500. If it is true, you should return an HTTP 200, with a body containing a `Success` and a `OrderId` property.

```csharp
...
catch (Exception ex) 
{
    ...
}

if (!response.Success)
{
    return StatusCode(500, "Something went wrong...");
}

return Ok(new { response.Success, response.OrderId });
```

That's everything that is needed for the endpoint.

### Adding gRPC tracing

Aspire supports tracing gRPC calls as well. However, it is turned off by default. So, you need to manually turn it on.

Open the __Extensions.cs__ file in the __WebDevWorkshop.ServiceDefaults__ project. 

If you scroll down a little, you will find some commented out code that says __Uncomment the following line to enable gRPC instrumentation__.

Uncomment the second line, adding the `AddGrpcClientInstrumentation()` call. This will add gRPC tracing. However, as mentioned in the comment above, you also need to install a NuGet package called __OpenTelemetry.Instrumentation.GrpcNetClient__.

__Warning:__ There is a caveat here. The __OpenTelemetry.Instrumentation.GrpcNetClient__ is still in pre-view at the time of writing. So, make sure that you have ticked the box to include pre-releases. Otherwise, you won't see it in the list of packages when you search for it.

Once the NuGet package has been installed, the call to `AddGrpcClientInstrumentation()` should be fine.

### Verify that it works

To verify that it works, press __F5__ to start debugging. 

In the website, start by making sure that you are logged in. Then add some products to the shopping cart. Once the products are in the cart, click on the cart, and then __Checkout__. 

As you can see, the checkout screen is already filled in with dummy data, so you just need to click __Place order__.

After a second of two, you should get a toast that says __Order placed successfully, thank you!__.

Sweet! It seems to work!

Let's just verify that the OTEL integration works as well.

Open the Aspire Dashboard and navigate to the __Traces__ section. 

One of the last traces should be one to __api/Orders__. It should have a box at the end that says __orders__, indicating that it included a call to the __orders__ resource.

![Open Telemetry Trace](../../resources/otel-trace.png)

If you click on that trace, you should see a full trace of the entire call, from it arriving to __webdevworkshop-web__, to the calls to the __products__ service, all the way to the __orders__ service. Including execution times etc.

### Emptying the shopping cart

Currently, the shopping cart isn't emptied when the order has been added. A feature that seems very useful. So, let's empty it after the order has completed.

As the shopping cart is maintained as a Orleans grain, you first need to update the grain interface to add the new functionality.

Open the __ShoppingCartGrain.cs__ file, in the __WebDevWorkshop.Web__ project, locate the `IShoppingCart` interface, and add a new method called __Clear()__. And since it is an interface for a grain, it needs to be async, thus return `Task`.

```csharp
public interface IShoppingCart : IGrainWithStringKey 
{ 
    ...
    Task Clear();
}
```

Next, scroll down to the `ShoppingCartGrain` class and create and implementation of the `Clear()` method. 

Now, you could just empty the list of items in the grain's state. But that would still leave an empty state object in the store. It is better to call the `ClearStateAsync()` method on the state, as this actually removes the state completely.

```csharp
public class ShoppingCartGrain : ...
{
    ...
    public Task Clear()
    {
        return state.ClearStateAsync();
    }
    ...
}
```

The downside to this, is that you still have a running grain. One that is unlikely to be used again right away, as the used has just checked out. 

So, it would be better that you told Orleans to remove the grain as well. And you can do that by calling the `DeactivateOnIdle()` method from the base class. This will make sure that the grain is removed as soon as the current method invocation is complete.

```csharp
public class ShoppingCartGrain : ...
{
    ...
    public Task Clear()
    {
        DeactivateOnIdle();
        return state.ClearStateAsync();
    }
    ...
}
```

Now, the last thing to do, is to call this new method on the shopping cart once the order has been added. But before you can do that, you need to have access to an instance of `IGrainFactory`.

So, open the __OrdersController.cs__ file and add a constructor parameter of the type `IGrainFactory` to the `OrdersController`.

```csharp
public class OrdersController(
    IProductsClient productsClient,
    OrdersService.OrdersServiceClient ordersService,
    IGrainFactory grainFactory
) : ControllerBase
```

Then locate the call to the `AddOrderAsync()` method, inside the `AddOrder()` action, Then add the following code right after it to, get hold of the users shopping cart grain and clear it

```csharp
...
try
{
    response = await ordersService.AddOrderAsync(request);

    var shoppingCart = grainFactory.GetGrain<IShoppingCart>(
        Request.Cookies["ShoppingCartId"]
    );
    await shoppingCart.Clear();
}
...
```

That's it!

### Verify that clearing the shopping cart works

Press __F5__ to start debugging. 

In the website, once again make sure that you you are logged in. Then add some products to the shopping cart, and go through the checkout.

After you get the __Order placed successfully, thank you!__ message, verify that the shopping cart disappears in the top righ corner.

[<< Lab 18](../lab18/lab18.md) | [Lab 20 >>](../lab20/lab20.md)